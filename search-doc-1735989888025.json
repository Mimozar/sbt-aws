{"searchDocs":[{"title":"SBT Interfaces","type":0,"sectionRef":"#","url":"/sbt-aws/docs/interfaces","content":"","keywords":"","version":"Next"},{"title":"IAuth Interface‚Äã","type":1,"pageTitle":"SBT Interfaces","url":"/sbt-aws/docs/interfaces#iauth-interface","content":" The IAuth interface defines the contracts for authentication and authorization in an application. It provides various configurations and endpoints related to JSON Web Tokens (JWT), OAuth, client IDs, client secrets, and scopes for different operations. Additionally, it includes Lambda functions for managing users.  Key features include:  üîë JWT and OAuth Configuration: Properties for setting up JWT issuer, audience, token endpoint, and OAuth client IDs and secrets.  üîç Scope Management: Scopes for authorizing requests related to tenant registration, user management, and other operations.  üë§ User Management: Lambda functions for creating, fetching, updating, enabling, and disabling users.  The interface ensures a consistent and standardized way of handling authentication and authorization across the application, making it easier to manage security-related configurations and user operations.  To learn more about the IAuth interface and its properties and methods, you can dive deeper into the documentation by clicking here.  ","version":"Next","tagName":"h2"},{"title":"IBilling Interface‚Äã","type":1,"pageTitle":"SBT Interfaces","url":"/sbt-aws/docs/interfaces#ibilling-interface","content":" The IBilling interface defines a standardized way of handling billing-related operations in a cloud-native application. It encapsulates functions for customer and user management, data ingestion, and usage data handling.  Key Features include:  üë™ Customer Management: Create and delete customers (entities that can have zero or more users).  üßë‚Äçü§ù‚Äçüßë User Management (Optional): Create and delete users belonging to customers.  üì• Data Ingestion (Optional): Aggregate raw billing data using a data ingestor.  üìä Usage Data Handling (Optional): Push aggregated data to the billing provider on a scheduled basis.  üîó Webhook Support (Optional): Trigger a function when a webhook request is received.  The interface includes properties for defining the required functions and their triggers, such as onboarding requests, offboarding requests, user creation/deletion events, and scheduled data pushes.  To learn more about the IBilling interface and its functions, you can dive deeper into the documentation by clicking here.  ","version":"Next","tagName":"h2"},{"title":"IMetering Interface‚Äã","type":1,"pageTitle":"SBT Interfaces","url":"/sbt-aws/docs/interfaces#imetering-interface","content":" The IMetering interface defines the contracts for metering operations in a system. It provides functions for managing meters, ingesting usage events, handling customer (tenant) operations, and retrieving usage data.  Key features include:  üìè Meter Management: Create, fetch, update, and delete meters used for tracking usage metrics.  üìä Usage Ingestion: Ingest usage events associated with meters to measure and analyze usage data.  üë§ Customer Management: Create and delete customers (tenants) for tracking usage.  üì• Usage Retrieval: Fetch usage data for specific meters, supporting features like pagination.  üóëÔ∏è Event Cancellation: Cancel or exclude specific usage events from being recorded.  The interface ensures a consistent and standardized way of handling metering operations, making it easier to integrate or replace the implementation in different parts of the system.  To learn more about the IMetering interface and its functions, you can dive deeper into the documentation by clicking here.  ","version":"Next","tagName":"h2"},{"title":"Appendix‚Äã","type":1,"pageTitle":"SBT Interfaces","url":"/sbt-aws/docs/interfaces#appendix","content":" Auth InterfaceMetering InterfaceBilling Interface ","version":"Next","tagName":"h2"},{"title":"IMetering Interface","type":0,"sectionRef":"#","url":"/sbt-aws/docs/interfaces/metering-interface","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"IMetering Interface","url":"/sbt-aws/docs/interfaces/metering-interface#overview","content":" The IMetering interface encapsulates the properties and functions required for metering operations in a system. It defines the contracts for various actions related to meter management, usage ingestion, customer (tenant) management, and usage data retrieval.  ","version":"Next","tagName":"h2"},{"title":"Properties‚Äã","type":1,"pageTitle":"IMetering Interface","url":"/sbt-aws/docs/interfaces/metering-interface#properties","content":" createMeterFunction (ISyncFunction): This function is responsible for creating a new meter. A meter is used to track and analyze specific usage metrics for tenants. It corresponds to the POST /meters endpoint. fetchMeterFunction (ISyncFunction): This function retrieves a single meter based on its unique identifier (id). It corresponds to the GET /meters/{meterId} endpoint. fetchAllMetersFunction (ISyncFunction): This function fetches multiple meters. It should support pagination to handle large result sets. It corresponds to the GET /meters endpoint. updateMeterFunction (Optional, ISyncFunction): This function updates an existing meter. It corresponds to the PUT /meters/{meterId} endpoint. deleteMeterFunction (Optional, ISyncFunction): This function deletes an existing meter. It corresponds to the DELETE /meters/{meterId} endpoint. ingestUsageEventFunction (IASyncFunction): This asynchronous function is responsible for ingesting a usage event. Usage events are used to measure and track the usage metrics associated with a meter. It is typically triggered by the INGEST_USAGE event. fetchUsageFunction (ISyncFunction): This function retrieves the usage data for a specific meter. It corresponds to the GET /usage/{meterId} endpoint. cancelUsageEventsFunction (Optional, ISyncFunction): This function is used to exclude specific events from being recorded or included in the usage data. It is helpful for canceling events that were incorrectly ingested. It corresponds to the DELETE /usage endpoint. createCustomerFunction (Optional, IASyncFunction): This asynchronous function is responsible for creating a new customer (tenant). It is typically triggered by the ONBOARDING_REQUEST event. deleteCustomerFunction (Optional, IASyncFunction): This asynchronous function is responsible for deleting an existing customer (tenant). It is typically triggered by the OFFBOARDING_REQUEST event.  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"IMetering Interface","url":"/sbt-aws/docs/interfaces/metering-interface#usage","content":" The IMetering interface can be implemented by a class or object that provides the required functionality for metering operations. The implementation should define the functions and properties according to the interface contract.  Here's an example of how the interface might be used:  import { IMetering } from './metering'; class MeteringService implements IMetering { // Implement the properties and functions defined in the IMetering interface } const meteringService = new MeteringService(); // Create a new meter const newMeterId = await meteringService.createMeterFunction({ /* meter data */ }); // Fetch a meter const meter = await meteringService.fetchMeterFunction({ meterId: newMeterId }); // Ingest a usage event await meteringService.ingestUsageEventFunction({ /* usage event data */ }); // Fetch usage data for a meter const usageData = await meteringService.fetchUsageFunction({ meterId: newMeterId });   By adhering to the IMetering interface, the implementation can be easily integrated into other parts of the system or replaced with a different implementation if needed, as long as the new implementation adheres to the same interface contract. ","version":"Next","tagName":"h2"},{"title":"IBilling Interface","type":0,"sectionRef":"#","url":"/sbt-aws/docs/interfaces/billing-interface","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#overview","content":" The IBilling interface encapsulates the list of properties for a billing construct. It includes functions for customer and user management, data ingestion, and usage data handling. This interface is designed to provide a standardized way of handling billing-related operations in a cloud-native application.  ","version":"Next","tagName":"h2"},{"title":"Properties‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#properties","content":" ","version":"Next","tagName":"h2"},{"title":"createCustomerFunction‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#createcustomerfunction","content":" Type: IASyncFunctionDescription: The async function responsible for creating a new customer. A customer in this context is an entity that can have zero or more users.Default Event Trigger: ONBOARDING_REQUEST  ","version":"Next","tagName":"h3"},{"title":"deleteCustomerFunction‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#deletecustomerfunction","content":" Type: IASyncFunctionDescription: The async function responsible for deleting an existing customer. A customer in this context is an entity that can have zero or more users.Default Event Trigger: OFFBOARDING_REQUEST  ","version":"Next","tagName":"h3"},{"title":"createUserFunction‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#createuserfunction","content":" Type: IASyncFunction (Optional)Description: The async function responsible for creating a new user. A user in this context is an entity that belongs to a customer.Default Event Trigger: TENANT_USER_CREATED  ","version":"Next","tagName":"h3"},{"title":"deleteUserFunction‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#deleteuserfunction","content":" Type: IASyncFunction (Optional)Description: The async function responsible for deleting an existing user. A user in this context is an entity that belongs to a customer.Default Event Trigger: TENANT_USER_DELETED  ","version":"Next","tagName":"h3"},{"title":"ingestor‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#ingestor","content":" Type: IDataIngestorAggregator (Optional)Description: The IDataIngestorAggregator responsible for accepting and aggregating raw billing data.  ","version":"Next","tagName":"h3"},{"title":"putUsageFunction‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#putusagefunction","content":" Type: IFunctionSchedule (Optional)Description: The async function responsible for taking the aggregated data and pushing it to the billing provider.Default Event Trigger: events.Schedule.rate(cdk.Duration.hours(24)) (Triggered every 24 hours)  ","version":"Next","tagName":"h3"},{"title":"webhookFunction‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#webhookfunction","content":" Type: IFunctionPath (Optional)Description: The function to trigger when a webhook request is received.Default HTTP Path: POST /billing/{$webhookPath}  ","version":"Next","tagName":"h3"},{"title":"Additional Interfaces‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#additional-interfaces","content":" ","version":"Next","tagName":"h2"},{"title":"IFunctionSchedule‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#ifunctionschedule","content":" This interface allows specifying both the function to trigger and the schedule by which to trigger it.  Properties:  handler: The function definition (IFunction).schedule: The schedule that will trigger the handler function (Schedule).  ","version":"Next","tagName":"h3"},{"title":"IFunctionPath‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#ifunctionpath","content":" This interface allows specifying both the function to trigger and the path on the API Gateway that triggers it.  Properties:  path: The path to the webhook resource (string).handler: The function definition (IFunction).  ","version":"Next","tagName":"h3"},{"title":"Usage‚Äã","type":1,"pageTitle":"IBilling Interface","url":"/sbt-aws/docs/interfaces/billing-interface#usage","content":" To use the IBilling interface, you need to implement the required properties and pass them to the billing construct. Here's an example:  import { IBilling } from 'your-billing-interface'; const billing: IBilling = { createCustomerFunction: /* Provide your implementation */, deleteCustomerFunction: /* Provide your implementation */, createUserFunction: /* Provide your implementation (optional) */, deleteUserFunction: /* Provide your implementation (optional) */, ingestor: /* Provide your implementation (optional) */, putUsageFunction: /* Provide your implementation (optional) */, webhookFunction: /* Provide your implementation (optional) */, }; // Pass the `billing` object to your billing construct const billingConstruct = new BillingConstruct(scope, 'BillingConstruct', billing);   In this example, you need to provide implementations for the required properties (createCustomerFunction and deleteCustomerFunction). The optional properties can be provided based on your specific requirements. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/sbt-aws/docs/partners/isv-integrations/amberflo","content":"","keywords":"","version":"Next"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#prerequisites","content":" Deploy a SBT Project: If you don't already have a SBT project deployed, follow AWS SBT's tutorial to deploy the sample hello-cdk project with a ControlPlane and CoreApplicationPlane. Amberflo Account: You need an Amberflo account for this project. If you don‚Äôt have an Amberflo account, you can sign up for one here: Amberflo Signup. API Key Secret: After signing up, the Amberflo API Key must be stored as a secret in AWS Secrets Manager. The application by default expects the secret to be created with the name AmberfloApiKey. However, you can create a secret with your own custom name and pass it in as a parameter to AmberfloMetering. Secret Name: The name of the secret in AWS Secrets Manager Secret Key: The key within the secret JSON that contains the API Key  ","version":"Next","tagName":"h2"},{"title":"Obtaining the Plugin‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#obtaining-the-plugin","content":" Option 1: Clone the repository  git clone https://github.com/amberflo/sbt-aws-amberflo.git  Option 2: Download the latest release Visit the sbt-aws-amberflo releases and download the latest version.  ","version":"Next","tagName":"h2"},{"title":"Installation Steps‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#installation-steps","content":" Within your SBT project directory, install aws-sbt-amberflo via the following command:  npm install --save sbt-aws-amberflo    ","version":"Next","tagName":"h2"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#configuration","content":" ","version":"Next","tagName":"h2"},{"title":"Add AmberfloMetering to Your Control Plane‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#add-amberflometering-to-your-control-plane","content":" Instantiate the AmberfloMetering construct in your AWS CDK stack. Here‚Äôs an example TypeScript code snippet:  import { Stack } from 'aws-cdk-lib'; import { Construct } from 'constructs'; import * as sbt from '@cdklabs/sbt-aws'; import { AmberfloMetering } from 'sbt-aws-amberflo'; export class ControlPlaneStack extends Stack { constructor(scope: Construct, id: string, props: any) { super(scope, id, props); const amberfloMetering = new AmberfloMetering(this, 'AmberfloMetering', { amberfloAPIKeySecretName: 'YourSecretName', amberfloAPIKeySecretId: 'YourSecretId', }); const controlPlane = new sbt.ControlPlane(this, 'ControlPlane', { metering: amberfloMetering, }); } }   ","version":"Next","tagName":"h3"},{"title":"Provision a Meter‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#provision-a-meter","content":" Once you deploy your updated stack, you can create and manage meters using the provided API endpoints. Here‚Äôs how you can create a meter:  METER=$(jq --null-input \\ '{ &quot;label&quot;: &quot;SBT Meter&quot;, &quot;meterApiName&quot;: &quot;sbt-meter&quot;, &quot;meterType&quot;: &quot;sum_of_all_usage&quot; }') echo &quot;creating meter...&quot; curl --request POST \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}meters&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --header 'content-type: application/json' \\ --data &quot;$METER&quot; | jq   The above 3 properties are the required properties for creating a meter. You can also pass in additional properties while creating a meter. See more on creating meters in Amberflo.  ","version":"Next","tagName":"h3"},{"title":"Update a Meter‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#update-a-meter","content":" Once you deploy your updated stack, you can update meters using the provided API endpoint. Here‚Äôs how you can update a meter:  UPDATE_METER=$(jq --null-input \\ '{ &quot;label&quot;: &quot;SBT trial meter&quot;, &quot;meterApiName&quot;: &quot;sbt-trial&quot;, &quot;meterType&quot;: &quot;sum_of_all_usage&quot; }') echo &quot;updating meter...&quot; curl --request PUT \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}meters/&lt;meter-id&gt;&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --header 'content-type: application/json' \\ --data &quot;$UPDATE_METER&quot; | jq   ","version":"Next","tagName":"h3"},{"title":"Get a Meter‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#get-a-meter","content":" You can get a meter by id using the provided API endpoint. Here‚Äôs how you can get a meter:  curl --request GET \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}meters/&lt;meterId&gt;&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --silent | jq   ","version":"Next","tagName":"h3"},{"title":"List all Meters‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#list-all-meters","content":" You can list all meters using the provided API endpoint. Here‚Äôs how you can list all meter:  curl --request GET \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}meters/&lt;meterId&gt;&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --silent | jq   ","version":"Next","tagName":"h3"},{"title":"Delete a Meter‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#delete-a-meter","content":" You can delete a meter by id using the provided API endpoint. Here‚Äôs how you can delete a meter:  curl --request DELETE \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}meters/&lt;meterId&gt;&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --silent | jq   ","version":"Next","tagName":"h3"},{"title":"Ingest Usage Events‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#ingest-usage-events","content":" To ingest usage events, application or service in the application plane must emit events that represent usage metrics, which will be processed by the ingestUsageEventFunction Lambda function.  Event details must contain the following required properties: ‚óè tenantId: The identifier of the tenant to associate with the usage. ‚óè meterApiName: The name of the meter as used in the createMeter. ‚óè meterValue: The quantity or amount of usage to record for a tenant. These properties are necessary to accurately track and attribute usage metrics. You can also pass in additional values for dimensions, if the meter has dimensions defined.  Example  const putEventsResponse = eventManager.eventBus.putEvents({ entries: [{ detail: { &quot;tenantId&quot;: &lt;tenantId&gt;, &quot;meterApiName&quot;: &lt;meterApiName as used in create meter&gt;, &quot;meterValue&quot;: &lt;usage value that is to be recorded&gt; }, detailType: DetailType.INGEST_USAGE, source: eventManager.applicationPlaneEventSource, }], });   The ingestUsageEventFunction Lambda function will be triggered to handle this event and send the data to Amberflo for processing.  Note: the eventManager is the eventManager passed to the CoreApplicationPlane  ","version":"Next","tagName":"h3"},{"title":"Fetch Usage Data‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#fetch-usage-data","content":" To fetch usage data, use the API endpoint to retrieve data based on your meter API name: Example  METER_API_NAME = 'sbt-meter' START_TIME = 1724630400 END_TIME = 1724716800 curl --request GET \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}usage/&lt;meterId&gt;?meterApiName=${METER_API_NAME}&amp;startTimeInSeconds=${START_TIME}&amp;endTimeInSeconds=${END_TIME}&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --silent | jq   The meterApiName id not provided in the query string will be fetched using the meterId path parameter. The startTimeInSeconds and endTimeInSeconds are optional and default to (current time - 24hrs) and current time.  ","version":"Next","tagName":"h3"},{"title":"Canceling incorrect usage events‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#canceling-incorrect-usage-events","content":" There are occasions where a meter event source may send or report incorrect or erroneous meters. Amberflo provides the ability to cancel (undo) one or more meter events as needed. See detailed guide on canceling usage events. Example  FILTER=$(jq --null-input \\ '{ &quot;id&quot;: &quot;sbt-filtering-rule&quot;, &quot;meterApiName&quot;: &quot;sbt-trial&quot;, &quot;ingestionTimeRange&quot;: { &quot;startTimeInSeconds&quot;: 1724367600, &quot;endTimeInSeconds&quot;: 1724371200 } }') echo &quot;creating filtering rule for canceling usage events...&quot; curl --request DELETE \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}usage&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --header 'content-type: application/json' \\ --data &quot;$FILTER&quot; | jq   The id, meterApiName and ingestionTimeRange are required parameters. The above command creates a filtering rule that cancels the events for the meter sbt-trial in the given time range. You can also cancel more specific events for specific tenants or based on specific dimensions etc. See the Amberflo API for more details.  ","version":"Next","tagName":"h3"},{"title":"Usage Examples‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#usage-examples","content":" The Amberflo metering implementation provided in this repository allows ISVs to integrate Amberflo with their SBT-based applications. This enables ISVs to:  Track and analyze usage metrics for their tenantsCreate a more accurate and efficient billing process  The AmberfloMetering construct deploys an AWS Lambda function to handle usage metering. It also provides a set of APIs for creating and updating meters, fetching usage, as well as ingesting usage events and canceling usage events. SaaS admins can use these endpoints for managing the application metering. The following endpoints are created in the control plane  Create Meter: POST /meters Update Meter: PUT /meters/{meterId} Ingest Usage: POST /ingest Cancel Usage: DELETE /usage Fetch Usage: GET /usage/meterId   Here's a brief overview of how this works:  Meter Creation: SaaS admins can create meters through the create meter API in control plane or through the Amberflo UI.Event Emission: Your application or service emits an ingest usage event with the necessary details to measure usage for a specific meter.Lambda Invocation: The ingestUsageEventFunction of AmberfloMetering is invoked automatically upon receiving the event.Data Processing: The Lambda function processes the event data and sends it to Amberflo for recording and subsequent usage analysis.Fetch Usage: SaaS admins can fetch usage through the fetch usage API in control plane or through the Amberflo UI.  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/amberflo#contributing","content":" We welcome contributions to improve the plugin! Please follow these steps:  Fork the Repository: Click the &quot;Fork&quot; button on the repository page to create your own copy.Create a Branch: Create a new branch for your feature or bug fix git checkout -b my-feature-branchMake Changes: Implement your feature or bug fix while adhering to existing coding standards.Write Tests: Add tests if applicable.Commit Your Changes: git commit -m &quot;Add feature X or fix issue Y&quot;Push to Your Fork: git push origin my-feature-branchSubmit a Pull Request: Open a pull request in the original repository with a clear description of your changes. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/sbt-aws/docs/partners/isv-integrations/descope","content":"","keywords":"","version":"Next"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#prerequisites","content":" Ensure you have a Descope account. If not, sign up hereHave access to a Descope Project, as well as a Management KeySet up an AWS SBT Project here  ","version":"Next","tagName":"h2"},{"title":"Obtaining the Plugin‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#obtaining-the-plugin","content":" Option 1: Import directly from npm  Within your SBT project directory, install sbt-aws-descope via the following command:  npm install --save @descope/sbt-aws-descope   Option 2: Download the latest release  Visit the GitHub releases page and download the latest version.  ","version":"Next","tagName":"h2"},{"title":"Installation Steps‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#installation-steps","content":" a. Follow the prerequisite steps to get started with the installation of this plugin. b. Clone the repo of the plugin provided. c. Install the Descope plugin's npm package within the SBT project downloaded as part of the prerequisites. d. Add DescopeAuth as part of your SBT's Control Plane construct. This way, SBT will use Descope as the identity provider, which implements the IAuth interface defined in the SBT core package.  ","version":"Next","tagName":"h2"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#configuration","content":" Step 1: Follow the prerequisite steps to prepare for plugin installation.  Step 2: Clone the plugin repository as provided in the options above.  Step 3: Install the Descope plugin's npm package within the SBT project:  npm install @descope/sbt-aws-descope   Step 4: Integrate DescopeAuth within your SBT‚Äôs Control Plane construct to enable Descope as the identity provider, implementing the IAuth interface as defined in the SBT core package.  import { DescopeAuth } from &quot;sbt-aws-descope&quot;; const descopeAuth = new DescopeAuth(this, &quot;DescopeAuth&quot;, { projectId: &quot;&lt;&lt;Descope Project ID&gt;&gt;&quot;, clientSecretSSMMgmtKey: &quot;&lt;&lt;Parameter Name in SSM of Descope Management Key&quot;, }); const controlPlane = new sbt.ControlPlane(this, &quot;ControlPlane&quot;, { auth: descopeAuth, systemAdminEmail: &quot;kevin@descope.com&quot;, });   Once you‚Äôve completed these steps, you should be able to build your SBT application and all of the built in functions will be set up for you. If you wish to add Flows or SDK/API based authentication methods to your app, you can follow our Quickstart guide.  Step 5: Usage Examples  Example 1: Implementing User Login with Passwordless Authentication Using Descope‚Äã  Descope's passwordless authentication provides a flexible, highly secure way to log in without traditional passwords, reducing the risk of phishing attacks and enhancing user convenience. With Descope, you can offer users a range of secure, passwordless login options, including passkeys, social login, and magic links‚Äîall of which improve security while simplifying the user experience.  Passkeys: Passkeys use a combination of device-based biometric verification (like fingerprint or Face ID) and cryptographic methods to authenticate users. This approach allows users to log in using only their device, without needing to enter any passwords. Implementing passkeys with Descope is straightforward, requiring only the user's consent to set up the device-based authentication. Passkeys are stored securely on the user's device, providing a phishing-resistant method of authentication that is seamless and familiar.Social Login: Descope supports a variety of social login providers, allowing users to authenticate via platforms they already use, like Google, Apple, or Facebook. This method enhances convenience while still ensuring a secure authentication process, as it reduces the need to create and remember yet another password.Magic Link: Magic links provide users with a one-time link sent directly to their email. When clicked, it logs the user in without requiring a password, making the process not only user-friendly but also resistant to phishing attacks. Since magic links are sent to the user's verified email, they ensure that the person logging in is indeed the account holder.  Benefits: Descope's passwordless options help prevent phishing by eliminating traditional passwords and offering cryptographic alternatives that are more secure. The variety of login methods allows you to choose the best option based on your application's user demographics and risk model, ensuring both security and convenience.  Example 2: Configuring multi-tenant user management to allow organization-specific login settings and access policies‚Äã  In a multi-tenant SaaS environment, organizations often have unique authentication needs, such as specific Single Sign-On (SSO) policies, access roles, and authorization rules. Descope enables you to manage each organization separately, providing customized login settings and role-based access control for each tenant.  SSO Self-Service Configuration: Descope enables tenant admins to configure SSO independently through a dedicated link. Once generated, this link lets an admin configure SSO settings, such as setting up SAML or OAuth integrations, without needing assistance from developers. Example Workflow: You can generate a self-service SSO link specific to the tenant, which can be shared with the tenant admin.Tenant Admin SSO Configuration: When the tenant admin accesses the link, they can complete the setup of SSO by following simple on-screen instructions. They can choose their identity provider, configure SAML assertions, and save the settings, allowing users within that tenant to log in through their chosen provider. Role-Based Access Control (RBAC): With Descope's tenant-level RBAC, you can assign users different roles based on the tenant's requirements, as well as map them from SAML groups that come from various external IdPs. For example, some users might have admin access, while others have read-only access. These roles can be configured on a per-tenant basis, allowing for flexible access control.Custom Tenant Authentication: Descope lets you configure different flow behaviors and styling per tenant, including MFA requirements, password settings, and device trust. This allows you to implement granular security controls based on the tenant's risk profile, such as requiring MFA for certain users.  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#troubleshooting","content":" Common Issues and Solutions:  Issue: &quot;User Management functions or Initial SBT plugin setup and configuration failing.&quot; Solution: Verify your Descope Management Key and permissions. Issue: &quot;Access denied errors when accessing SBT control plane.&quot; Solution: Ensure the Descope plugin is properly installed and referenced in your SBT configuration.  Additional Support: For detailed support, please refer to Descope Support.  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#contributing","content":" If you would like to contribute to the development of this plugin, please refer to our contribution guidelines on GitHub. Contributions are welcome and encouraged to improve functionality and usability.  ","version":"Next","tagName":"h2"},{"title":"Architecture Diagram‚Äã","type":1,"pageTitle":"Introduction","url":"/sbt-aws/docs/partners/isv-integrations/descope#architecture-diagram","content":" Example:   ","version":"Next","tagName":"h3"},{"title":"IAuth Interface","type":0,"sectionRef":"#","url":"/sbt-aws/docs/interfaces/auth-interface","content":"","keywords":"","version":"Next"},{"title":"Overview‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#overview","content":" The IAuth interface encapsulates the properties and methods required for authentication and authorization in the application. It provides various configurations and endpoints related to JSON Web Tokens (JWT), OAuth, client IDs, client secrets, and scopes for different operations. Additionally, it includes Lambda functions for managing users.  ","version":"Next","tagName":"h2"},{"title":"Properties‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#properties","content":" ","version":"Next","tagName":"h2"},{"title":"jwtIssuer‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#jwtissuer","content":" Type: stringDescription: The JWT issuer domain for the identity provider. This is the domain where the JSON Web Tokens (JWTs) are issued from.  ","version":"Next","tagName":"h3"},{"title":"jwtAudience‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#jwtaudience","content":" Type: string[]Description: The list of recipients (audience) for which the JWT is intended. This will be checked by the API Gateway to ensure only authorized clients are provided access.  ","version":"Next","tagName":"h3"},{"title":"tokenEndpoint‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#tokenendpoint","content":" Type: stringDescription: The endpoint URL for granting OAuth tokens. This is the URL where OAuth tokens can be obtained from the authorization server.  ","version":"Next","tagName":"h3"},{"title":"userClientId‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#userclientid","content":" Type: stringDescription: The client ID enabled for user-centric authentication flows, such as Authorization Code flow. This client ID is used for authenticating end-users.  ","version":"Next","tagName":"h3"},{"title":"machineClientId‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#machineclientid","content":" Type: stringDescription: The client ID enabled for machine-to-machine authorization flows, such as Client Credentials flow. This client ID is used for authenticating applications or services.  ","version":"Next","tagName":"h3"},{"title":"machineClientSecret‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#machineclientsecret","content":" Type: SecretValueDescription: The client secret enabled for machine-to-machine authorization flows, such as Client Credentials flow. This secret is used in combination with the machine client ID for authenticating applications or services.  ","version":"Next","tagName":"h3"},{"title":"machineClientAudience‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#machineclientaudience","content":" Type: string | undefinedDescription: The audience for the machine client. If provided, this value will be used in the call to generate the access token for the Client Credentials flow.  ","version":"Next","tagName":"h3"},{"title":"fetchTenantRegistrationScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#fetchtenantregistrationscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for fetching a single tenant registration. This scope grants permission to fetch the details of a specific tenant registration.  ","version":"Next","tagName":"h3"},{"title":"fetchAllTenantRegistrationsScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#fetchalltenantregistrationsscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for fetching all tenants. This scope grants permission to fetch the details of all tenants.  ","version":"Next","tagName":"h3"},{"title":"deleteTenantRegistrationScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#deletetenantregistrationscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for deleting a tenant registration. This scope grants permission to delete a specific tenant registration.  ","version":"Next","tagName":"h3"},{"title":"createTenantRegistrationScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#createtenantregistrationscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for creating a tenant registration. This scope grants permission to create a new tenant registration.  ","version":"Next","tagName":"h3"},{"title":"updateTenantRegistrationScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#updatetenantregistrationscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for updating a tenant registration. This scope grants permission to update the details of a specific tenant registration.  ","version":"Next","tagName":"h3"},{"title":"activateTenantRegistrationScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#activatetenantregistrationscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for activating a tenant via the tenant registration endpoint. This scope grants permission to activate a specific tenant.  ","version":"Next","tagName":"h3"},{"title":"deactivateTenantRegistrationScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#deactivatetenantregistrationscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for deactivating a tenant via the tenant registration endpoint. This scope grants permission to deactivate a specific tenant.  ","version":"Next","tagName":"h3"},{"title":"fetchUserScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#fetchuserscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for fetching a single user. This scope grants permission to fetch the details of a specific user.  ","version":"Next","tagName":"h3"},{"title":"fetchAllUsersScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#fetchallusersscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for fetching all users. This scope grants permission to fetch the details of all users.  ","version":"Next","tagName":"h3"},{"title":"deleteUserScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#deleteuserscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for deleting a user. This scope grants permission to delete a specific user.  ","version":"Next","tagName":"h3"},{"title":"createUserScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#createuserscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for creating a user. This scope grants permission to create a new user.  ","version":"Next","tagName":"h3"},{"title":"updateUserScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#updateuserscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for updating a user. This scope grants permission to update the details of a specific user.  ","version":"Next","tagName":"h3"},{"title":"disableUserScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#disableuserscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for disabling a user. This scope grants permission to disable a specific user.  ","version":"Next","tagName":"h3"},{"title":"enableUserScope‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#enableuserscope","content":" Type: string | undefinedDescription: The scope required to authorize requests for enabling a user. This scope grants permission to enable a specific user.  ","version":"Next","tagName":"h3"},{"title":"wellKnownEndpointUrl‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#wellknownendpointurl","content":" Type: stringDescription: The well-known endpoint URL for the control plane identity provider. This URL provides configuration information about the identity provider, such as issuer, authorization endpoint, and token endpoint.  ","version":"Next","tagName":"h3"},{"title":"createUserFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#createuserfunction","content":" Type: IFunctionDescription: The Lambda function for creating a user. (POST /users)  ","version":"Next","tagName":"h3"},{"title":"fetchAllUsersFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#fetchallusersfunction","content":" Type: IFunctionDescription: The Lambda function for fetching all users. (GET /users)  ","version":"Next","tagName":"h3"},{"title":"fetchUserFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#fetchuserfunction","content":" Type: IFunctionDescription: The Lambda function for fetching a user. (GET /user/{userId})  ","version":"Next","tagName":"h3"},{"title":"updateUserFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#updateuserfunction","content":" Type: IFunctionDescription: The Lambda function for updating a user. (PUT /user/{userId})  ","version":"Next","tagName":"h3"},{"title":"deleteUserFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#deleteuserfunction","content":" Type: IFunctionDescription: The Lambda function for deleting a user. (DELETE /user/{userId})  ","version":"Next","tagName":"h3"},{"title":"disableUserFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#disableuserfunction","content":" Type: IFunctionDescription: The Lambda function for disabling a user. (PUT /user/{userId}/disable)  ","version":"Next","tagName":"h3"},{"title":"enableUserFunction‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#enableuserfunction","content":" Type: IFunctionDescription: The Lambda function for enabling a user. (PUT /user/{userId}/enable)  ","version":"Next","tagName":"h3"},{"title":"Methods‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#methods","content":" ","version":"Next","tagName":"h2"},{"title":"createAdminUser(scope: Construct, id: string, props: CreateAdminUserProps): void‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#createadminuserscope-construct-id-string-props-createadminuserprops-void","content":" Description: Function to create an admin user.Parameters: scope (Construct): The scope in which the admin user should be created.id (string): The unique identifier for the admin user.props (CreateAdminUserProps): An object containing the properties for creating the admin user.  The CreateAdminUserProps interface has the following properties:  name (string): The name of the new admin user.email (string): The email address of the new admin user.role (string): The name of the role of the new admin user.  ","version":"Next","tagName":"h3"},{"title":"Usage‚Äã","type":1,"pageTitle":"IAuth Interface","url":"/sbt-aws/docs/interfaces/auth-interface#usage","content":" To use the IAuth interface, you'll need to implement it and provide the required configurations and Lambda functions. Here's an example of how you might use it:  import { IAuth, CreateAdminUserProps } from './auth-interface'; class MyAuth implements IAuth { // Implement the properties and methods of the IAuth interface // ... createAdminUser(scope: Construct, id: string, props: CreateAdminUserProps): void { // Implement the logic to create an admin user // ... } } const myAuth = new MyAuth(); // Use the properties and methods of the IAuth interface const jwtIssuer = myAuth.jwtIssuer; const tokenEndpoint = myAuth.tokenEndpoint; // Create an admin user const adminUserProps: CreateAdminUserProps = { name: 'John Doe', email: 'john.doe@example.com', role: 'Admin', }; myAuth.createAdminUser(this, 'AdminUser', adminUserProps);  ","version":"Next","tagName":"h2"},{"title":"Amazon ECS SaaS - Reference Architecture","type":0,"sectionRef":"#","url":"/sbt-aws/docs/reference_architectures/ecs-reference-architecture","content":"","keywords":"","version":"Next"},{"title":"Key Features‚Äã","type":1,"pageTitle":"Amazon ECS SaaS - Reference Architecture","url":"/sbt-aws/docs/reference_architectures/ecs-reference-architecture#key-features","content":" Multi-Tenant Architecture: The architecture supports different tenant isolation strategies, including pooled and silo models, across three tiers: Basic, Advanced, and Premium. These tiers offer varying levels of resource sharing and isolation to meet different tenant needs.AWS Integration: The solution leverages native AWS services for routing, observability, and service discovery. It uses AWS CloudFormation, AWS CDK, and ECS Service Connect for seamless integration and management of services.AWS SaaS Builder Toolkit (SBT): This toolkit extends the SaaS control plane with functionalities like tenant onboarding, user management, and billing. It also integrates with the ECS application plane for bi-directional communication necessary for SaaS operations.  ","version":"Next","tagName":"h2"},{"title":"Architectural Tiers‚Äã","type":1,"pageTitle":"Amazon ECS SaaS - Reference Architecture","url":"/sbt-aws/docs/reference_architectures/ecs-reference-architecture#architectural-tiers","content":" Basic Tier: Utilizes shared ECS services across all tenants in a pooled model. This tier is preloaded in the baseline architecture and shares resources like product and order microservices.Advanced Tier: Features a shared ECS cluster with dedicated ECS services per tenant, following a silo model. This setup provides more isolation compared to the Basic tier.Premium Tier: Offers dedicated ECS clusters per tenant, providing the highest level of isolation and customization for each tenant.  ","version":"Next","tagName":"h2"},{"title":"GitHub Repository‚Äã","type":1,"pageTitle":"Amazon ECS SaaS - Reference Architecture","url":"/sbt-aws/docs/reference_architectures/ecs-reference-architecture#github-repository","content":" For a complete implementation of the sample architecture for this pattern, see the GitHub repository ","version":"Next","tagName":"h2"},{"title":"Amazon EKS SaaS Reference Architecture","type":0,"sectionRef":"#","url":"/sbt-aws/docs/reference_architectures/eks-reference-architecture","content":"","keywords":"","version":"Next"},{"title":"Key Components‚Äã","type":1,"pageTitle":"Amazon EKS SaaS Reference Architecture","url":"/sbt-aws/docs/reference_architectures/eks-reference-architecture#key-components","content":" Multi-Tenant Isolation: The architecture emphasizes tenant isolation, which is crucial for ensuring that each tenant's data and operations are secure and separate from others. This is achieved through Kubernetes namespaces and network policies.Identity and Access Management: Amazon Cognito is used for managing user identities and access controls, ensuring that tenant-specific access policies are enforced.Data Partitioning: Data for each tenant is partitioned to maintain privacy and security. This can involve using separate databases or schemas for each tenant, depending on the application's requirements.Deployment Automation: The architecture supports automated deployment processes, often using AWS CodePipeline, to streamline the onboarding of new tenants and updates to the application.Microservices Architecture: The solution leverages a microservices architecture, allowing for modular development and deployment. This approach supports scalability and flexibility in managing different components of the application.Operational Management: Shared services within the EKS cluster handle common operational tasks such as logging, monitoring, and configuration management, which are essential for maintaining a robust SaaS environment. This reference architecture serves as a starting point for developing SaaS applications on AWS using EKS, providing practical examples and best practices to address common challenges in multi-tenant environments.  GitHub Repository  For a complete implementation of the sample architecture for this pattern, see the GitHub repository ","version":"Next","tagName":"h2"},{"title":"SaaS Builder Toolkit for AWS Workshop","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/sbt-workshop/workshop","content":"SaaS Builder Toolkit for AWS Workshop For a detailed step by step walkthrough, click this link to follow along in a workshop. In this workshop, you will walk through the development of a multi-tenant Software-as-a-Service (SaaS) solution using the SaaS Builder Toolkit for AWS (SBT). SBT is an open-source toolkit designed to streamline and accelerate the development of SaaS applications by encapsulating best practices and common patterns into reusable components. As SaaS continues to dominate the software delivery model, the ability to rapidly deploy and scale applications becomes increasingly crucial. SBT utilizes the robust AWS Cloud Development Kit (CDK) to provide developers with high-level object-oriented abstractions, enabling a focus on building unique features rather than managing the underlying infrastructure. This workshop guide is structured into five comprehensive labs (with two optional ones), each aimed at enhancing your understanding and skills in utilizing the SBT to its full potential. By the end of this workshop, you will have built a fully functional SaaS application. It's important to note that prior knowledge of SBT is not required for this workshop. Instead, you can use this workshop as a step-by-step guide to gain a deeper understanding of the SBT components, enhancing your ability to effectively utilize these tools in building scalable SaaS solutions.","keywords":"","version":"Next"},{"title":"Moesif API Monetization for AWS SBT","type":0,"sectionRef":"#","url":"/sbt-aws/docs/partners/isv-integrations/moesif","content":"","keywords":"","version":"Next"},{"title":"How it works‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#how-it-works","content":" ","version":"Next","tagName":"h2"},{"title":"Event Ingestion‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#event-ingestion","content":" The project deploys an Amazon Data Firehose to ingest your raw usage events. Events can be API Calls such as from an Amazon API Gateway instance or custom actions triggered within your application. The firehose will send all events to Moesif's Collection API for metering and analytics.    For more info on how the MoesifFirehoseConstruct works, view Moesif docs on ingesting actions via Firehose  ","version":"Next","tagName":"h3"},{"title":"User and Tenant Management‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#user-and-tenant-management","content":" The project also deploys a Lambda Function for user and tenant management. The lambda will listen to events like provisionSuccess to create companies and subscriptions in Moesif and your payment provider. Similarly, when receiving a deprovisionSuccess event, all subscriptions will be canceled for the tenant. You can inspect the code here.  SBT Entity\tMoesif Entity\tDescription\tParentTenant\tCompany\tYour customer that you provisioned resources for.\tNone Tenant\tSubscription\tA single subscription for a company/tenant.\tCompany User\tUser\tEnd users of your customer who login to your SaaS.\tCompany  ","version":"Next","tagName":"h3"},{"title":"How to use‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#how-to-use","content":" ","version":"Next","tagName":"h2"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#prerequisites","content":" If you don't already have a SBT project deployed, follow AWS SBT's tutorial to deploy the sample hello-cdk project with a ControlPlane and CoreApplicationPlane.You already have a Moesif account. You can sign up for a trial on moesif.com  ","version":"Next","tagName":"h3"},{"title":"1. Install the NPM package‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#1-install-the-npm-package","content":" Within your SBT project directory, install sbt-aws-moesif via the following command:  npm install --save sbt-aws-moesif   ","version":"Next","tagName":"h3"},{"title":"2. Add MoesifBilling to your ControlPlane‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#2-add-moesifbilling-to-your-controlplane","content":" Instantiate the MoesifBilling construct like below. You will need to set some properties to authenticate with Moesif.  export class ControlPlaneStack extends Stack { public readonly regApiGatewayUrl: string; public readonly eventBusArn: string; constructor(scope: Construct, id: string, props: any) { super(scope, id, props); const cognitoAuth = new CognitoAuth(this, 'CognitoAuth', { idpName: 'COGNITO', systemAdminRoleName: 'SystemAdmin', systemAdminEmail: '&lt;&lt;Your Admin Email&gt;&gt;', }); const moesifBilling = new MoesifBilling(stack, 'MoesifBilling', { moesifApplicationId: '&lt;&lt;Your Moesif Application Id&gt;&gt;', moesifManagementAPIKey: '&lt;&lt;Your Moesif Management API Key&gt;&gt;', billingProviderSlug: BillingProviderSlug.STRIPE, billingProviderSecretKey: '&lt;&lt;Your Billing Provider\\'s Secret Such as for Stripe&gt;&gt;' } ); const controlPlane = new ControlPlane(this, 'ControlPlane', { auth: cognitoAuth, billing: moesifBilling, }); this.eventBusArn = controlPlane.eventBusArn; this.regApiGatewayUrl = controlPlane.controlPlaneAPIGatewayUrl; } }   ","version":"Next","tagName":"h3"},{"title":"Moesif Billing Properties‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#moesif-billing-properties","content":" Property Name\tType\tRequired\tDescription\tDefaultmoesifApplicationId\tstring\tRequired\tCollector Application Id from your Moesif account for event ingestion moesifManagementAPIKey\tstring\tRequired\tManagement API Key from your Moesif account. The key must have the following scopes: create:companies create:subscriptions create:users delete:companies delete:subscriptions delete:users moesifManagementAPIBaseUrl\tstring Override the base URL for the Moesif Mangaement API. For most setups, you don't need to set this.\thttps://api.moesif.com moesifCollectorAPIBaseUrl\tstring Override the base URL for the Moesif Collector API. For most setups, you don't need to set this.\thttps://api.moesif.net billingProviderSlug\tBillingProviderSlug\tRequired\tSlug for Billing Provider / Payment Gateway billingProviderSecretKey\tstring\tRequired\tSecret Key for Billing Provider / Payment Gateway selected by billingProviderSlug billingProviderClientId\tstring\tOnly if Zuora\tClient Id for Billing Provider / Payment Gateway. Only used when billingProviderSlug is Zuora billingProviderBaseUrl\tstring\tOnly if Chargebee or Zuora\tBase URL for Billing Provider / Payment Gateway. Only used when billingProviderSlug is Zuora or Chargebee tenantPlanField\tstring Tenant object's field name that contains the plan id used when creating new subscriptions. Only used when billingProviderSlug is Zuora\tplanId tenantPriceField\tstring Tenant object's field name that contains the price id used when creating new subscriptions.\tpriceId firehoseName\tstring The name of the Kinesis Firehose delivery stream. By default, a unique name will be generated. bucketName\tstring The name of the S3 bucket for backup. By default, a unique name will be generated. schema\tstring Moesif Event Schema for data ingestion. By default, Moesif actions\t  ","version":"Next","tagName":"h3"},{"title":"3. Provision a Tenant‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#3-provision-a-tenant","content":" Once you deploy your updated stack, create a tenant in your AWS SBT setup using the SBT APIs.  When you create a tenant, you must also set the price id to be used for creating subscriptions, By default, the field name is priceId, but this can be overridden via the above options. If you are using Zuora, you must also set the plan id. The field email must also be set.  If your provider is set to Zuora, you must also set these fields  If you're running the hello-cdk project, this can be done by running this script to onboard a new tenant. Modify, the script to also include the price (and plan if required).  To find your plan id and price id, you can log into Moesif UI and go to Product Catalog or log into your billing provider.  DATA=$(jq --null-input \\ --arg tenantEmail &quot;$TENANT_EMAIL&quot; \\ --arg tenantId &quot;$TENANT_ID&quot; \\ '{ &quot;email&quot;: $tenantEmail, &quot;tenantId&quot;: $tenantId, &quot;priceId&quot;: &quot;price_1MoBy5LkdIwHu7ixZhnattbh&quot; }') echo &quot;creating tenant...&quot; curl --request POST \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}tenants&quot; \\ --header &quot;Authorization: Bearer ${ID_TOKEN}&quot; \\ --header 'content-type: application/json' \\ --data &quot;$DATA&quot;   Once done, you should see the company show up in the Moesif UI. There should also be a subscription for the company in the &quot;active&quot; status.  The tenant will be subscribed to the price defined by defaultPriceId. This can be expanded to allow more customization.  ","version":"Next","tagName":"h3"},{"title":"4. Ingest Events‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#4-ingest-events","content":" Now that you created a tenant, you should ingest some actions in you're newly created firehose. Actions have an action name (like &quot;Signed Up&quot;, &quot;API Request&quot;, or &quot;Finished Job&quot;) which represents the usage event. You can also include arbitrary metadata with an action, which enables you to create billable metrics, usage reporting, and more. For more info, see docs on actions  You'll want to set a few fields like below:  action_name is a string and should include name of the event such as &quot;Processed Payment Transaction&quot;company_id is your tenant identifier. See companiestransaction_id should be a random UUID for this event which Moesif uses for deduplication. Docs on Moesif idempotency.request.time represents the transaction time as an ISO formatted string.metadata is an object which includes any custom properties for this event. By setting metadata, you can bill on arbitrary metrics, create metrics on them, etc. For example, if the action name is &quot;Processed Payment Transaction&quot;, you can include an amount and the currency to bill on the total amount.  For full schema and available fields, see Actions API Reference  An example action is below:  { &quot;action_name&quot;: &quot;Processed Payment Transaction&quot;, &quot;request&quot;: { &quot;time&quot;: &quot;2024-03-01T04:45:42.914&quot; }, &quot;company_id&quot;: &quot;12345&quot;, // This is your tenant id &quot;transaction_id&quot;: &quot;a3765025-46ec-45dd-bc83-b136c8d1d257&quot;, &quot;metadata&quot;: { &quot;amount&quot;: 24.6, &quot;currency&quot;: &quot;USD&quot;, &quot;time_seconds&quot;: 66.3 } }   In the above example, the action is created whenever a payment is processed. There are also two metrics we are tracking as part of the action (the amount of the payment and how long the job took). You can create billable metrics and usage reports from these attributes.  If your events are API calls, we recommend changing the MoesifEventSchema to API_CALL which provides a different schema than the above actions. See API Calls  ","version":"Next","tagName":"h3"},{"title":"5. Create a Billing Meter‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#5-create-a-billing-meter","content":" Now that the tenant is created, follow these steps to create a billing meter in Moesif. The billing meter can filter or aggregate on any of the metadata fields you included with your action.  You should also select the provider and price defined by billingProviderSlug and defaultPriceId.  ","version":"Next","tagName":"h3"},{"title":"Provider Specific Requirements‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#provider-specific-requirements","content":" ","version":"Next","tagName":"h2"},{"title":"Zuora‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#zuora","content":" If you are using Zuora, the following fields must be set when creating a new tenant:  { &quot;email&quot;: &quot;&lt;Customer email address&gt;&quot;, &quot;firstName&quot;: &quot;&lt;First name of customer contact&gt;&quot;, &quot;lastName&quot;: &quot;&lt;Last name of customer contact&gt;&quot;, &quot;currency&quot;: &quot;&lt;Three-letter ISO currency code&gt;&quot;, &quot;address&quot;: { &quot;state&quot;: &quot;&lt;State or providence of the contact's address&gt;&quot;, &quot;country&quot;: &quot;&lt;The country of the contact's address&gt;&quot; } }   ","version":"Next","tagName":"h3"},{"title":"Limitations‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#limitations","content":" sbt-aws-moesif is in preview. Development is still ongoing. There are limitations to be aware of.  Deprovisioning a tenant will cancel all subscriptions but does not delete objects in case a subscription should be reactivated.  ","version":"Next","tagName":"h2"},{"title":"Useful commands‚Äã","type":1,"pageTitle":"Moesif API Monetization for AWS SBT","url":"/sbt-aws/docs/partners/isv-integrations/moesif#useful-commands","content":" npm run build compile typescript to jsnpm run watch watch for changes and compilenpm run test perform the jest unit tests ","version":"Next","tagName":"h2"},{"title":"Serverless SaaS - Reference Solution","type":0,"sectionRef":"#","url":"/sbt-aws/docs/reference_architectures/serverless-saas-reference-architecture","content":"","keywords":"","version":"Next"},{"title":"Key Components‚Äã","type":1,"pageTitle":"Serverless SaaS - Reference Solution","url":"/sbt-aws/docs/reference_architectures/serverless-saas-reference-architecture#key-components","content":" Control Plane: This is where tenant management and operational services reside. It includes components for registration, onboarding, and provisioning of tenants. The control plane is crucial for managing the lifecycle of tenants in a SaaS environment.Application Plane: This consists of the core application services that handle business logic and data processing. It typically involves AWS Lambda for compute, Amazon API Gateway for routing requests, and Amazon DynamoDB for data storage.Identity and Access Management: Amazon Cognito is used for user authentication and authorization, providing a secure way to manage user identities across different tenants.  ","version":"Next","tagName":"h2"},{"title":"Architectural Strategies‚Äã","type":1,"pageTitle":"Serverless SaaS - Reference Solution","url":"/sbt-aws/docs/reference_architectures/serverless-saas-reference-architecture#architectural-strategies","content":" Serverless Model: By using serverless services like AWS Lambda, the architecture reduces operational overhead and allows automatic scaling based on demand. This model aligns resource consumption with tenant activity, optimizing cost efficiency.Multi-Tenant Management: The architecture supports both pooled and siloed deployment models, allowing flexibility in how resources are shared or isolated among tenants. This can be configured using AWS Lambda layers and API Gateway usage plans to manage tenant-specific configurations.Deployment Automation: The reference architecture includes automated deployment pipelines using AWS CodePipeline, enabling continuous integration and delivery of updates across all tenants.  GitHub Repository  For a complete implementation of the sample architecture for this pattern, see the GitHub repository ","version":"Next","tagName":"h2"},{"title":"Build the control plane","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/build-it","content":"Build the control plane Now let's build and deploy this component. Before we do, we have to modify one other file. Open up the hello-cdk.ts file in the bin directory, and replace everything that's in there with the following contents: #!/usr/bin/env node import 'source-map-support/register'; import * as cdk from 'aws-cdk-lib'; import { ControlPlaneStack } from '../lib/control-plane'; // import { AppPlaneStack } from '../lib/app-plane'; const app = new cdk.App(); const controlPlaneStack = new ControlPlaneStack(app, 'ControlPlaneStack'); // const appPlaneStack = new AppPlaneStack(app, 'AppPlaneStack', { // eventManager: controlPlaneStack.eventManager, // }); Notice we're leaving a few lines commented out here, we'll come back to those later when we discuss the application plane. Ensure everything is saved, then from the root of your hello-cdk project, run the following: warning Because our control plane deploys Lambda functions, you'll need Docker installed to build and deploy this CDK stack npm run build cdk bootstrap cdk deploy ControlPlaneStack This will kick of the synthesis of your CDK application to AWS CloudFormation, then deploy that CloudFormation. Behind the scenes, a lot is getting created. This construct not only stands up the surface of our control plane API, using a new API Gateway component, it also deploys several services as AWS Lambda functions used for tenant provisioning and management. Feel free to open your AWS Console and take a look at the following (ensure you're in the same region you deployed to): AWS LambdaAmazon CognitoAPI Gateway Once done, we now have the left side of our conceptual diagram deployed, and we did it with just a few constructs. It deployed not only the API surface of our control plane, but also wired it up to EventBridge. Next, we'll start deploy the application plane, and connect it to the same EventBridge bus, so we can act upon those control plane messages.","keywords":"","version":"Next"},{"title":"Application plane utilities","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/app-plane-utils","content":"Application plane utilities Although entirely optional, SBT includes a utility that lets you define, and run arbitrary jobs upon receipt of a control plane message, called a ScriptJob. This mechanism is extended to produce two new helper constructs ProvisioningScriptJob and DeprovisioningScriptJob which are used for onboarding and off-boarding, respectively, in the reference architectures which were ported to SBT (see references at the end of this document). That tenant provisioning/deprovisioning process is depicted below: Notice the use of the provisioning.sh and deprovisioning.sh scripts at the top. These scripts are fed to the ProvisioningScriptJob and DeprovisioningScriptJob as parameters. Internally the ScriptJob launches an AWS CodeBuild project, wrapped inside an AWS Step Function, to execute the bash scripts. The ScriptJob also lets you specify what input variables to feed to the scripts, along with what output variables you expect them to return. Note that in this version of SBT, you can create the ScriptJob construct with ScriptJobProps and configure CoreAppPlane with ScriptJobs using its scriptJobs property. The CoreAppPlane will then link these ScriptJobs to EventBridge. Let's take a simple example: imagine our SaaS application deployed only a single S3 bucket per tenant. Let's create a ProvisioningScriptJob for that provisioning now: const scriptJobProps: TenantLifecycleScriptJobProps = { permissions: PolicyDocument.fromJson(/*See below*/), script: '' /*See below*/, environmentStringVariablesFromIncomingEvent: ['tenantId', 'tier'], environmentVariablesToOutgoingEvent: ['tenantS3Bucket', 'someOtherVariable', 'tenantConfig'], scriptEnvironmentVariables: { TEST: 'test', }, eventManager: eventManager /*See below on how to create EventManager*/, }; Key\tType\tPurposescript\tstring\tA string in bash script format that represents the job to be run (example below) permissions\tPolicyDocument\tAn IAM policy document giving this job the IAM permissions it needs to do what it's being asked to do environmentStringVariablesFromIncomingEvent\tstring[]\tThe environment variables to import into the ScriptJob from event details field. environmentVariablesToOutgoingEvent\tstring[]\tThe environment variables to export into the outgoing event once the ScriptJob has finished. scriptEnvironmentVariables\t{ [key: string]: string }\tThe variables to pass into the codebuild ScriptJob. eventManager\tIEventManager\tThe EventManager instance that allows connecting to events flowing between the Control Plane and other components. The heavy lifting of the ScriptJob construct (along with constructs that extend it like ProvisioningScriptJob) happens with the value of the script key. Let's take a look at the example provisioning script now: echo &quot;starting...&quot; # note that this template.json is being created here, but # it could just as easily be pulled in from an S3 bucket. cat &gt; template.json &lt;&lt; EOM { &quot;AWSTemplateFormatVersion&quot;: &quot;2010-09-09&quot;, &quot;Resources&quot;: {&quot;MyBucket&quot;: {&quot;Type&quot;: &quot;AWS::S3::Bucket&quot;}}, &quot;Outputs&quot;: {&quot;S3Bucket&quot;: {&quot;Value&quot;: { &quot;Ref&quot;: &quot;MyBucket&quot; }}} } EOM echo &quot;tenantId: $tenantId&quot; echo &quot;tier: $tier&quot; aws cloudformation create-stack --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; --template-body &quot;file://template.json&quot; aws cloudformation wait stack-create-complete --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; export tenantS3Bucket=$(aws cloudformation describe-stacks --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; | jq -r '.Stacks[0].Outputs[0].OutputValue') export someOtherVariable=&quot;this is a test&quot; echo $tenantS3Bucket export tenantConfig=$(jq --arg SAAS_APP_USERPOOL_ID &quot;MY_SAAS_APP_USERPOOL_ID&quot; \\ --arg SAAS_APP_CLIENT_ID &quot;MY_SAAS_APP_CLIENT_ID&quot; \\ --arg API_GATEWAY_URL &quot;MY_API_GATEWAY_URL&quot; \\ -n '{&quot;userPoolId&quot;:$SAAS_APP_USERPOOL_ID,&quot;appClientId&quot;:$SAAS_APP_CLIENT_ID,&quot;apiGatewayUrl&quot;:$API_GATEWAY_URL}') echo $tenantConfig export tenantStatus=&quot;created&quot; echo &quot;done!&quot; ","keywords":"","version":"Next"},{"title":"Congratulations!","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/congratulations","content":"Congratulations!","keywords":"","version":"Next"},{"title":"Create the application plane","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/create-application-plane","content":"Create the application plane As mentioned before, SBT is unopinionated about the application in which it's deployed. As a result, we expect you to create the ApplicationPlane construct as just another part of the CDK constructs that you'd use to define your application. Take this simple (non-functional) example: export interface AppPlaneProps extends cdk.StackProps { eventManager: sbt.IEventManager; } export class ApplicationPlaneStack extends Stack { constructor(scope: Construct, id: string, props: AppPlaneProps) { super(scope, id, props); new sbt.CoreApplicationPlane(this, 'CoreApplicationPlane', { eventManager: props.eventManager, scriptJobs: [], }); } } In this example we're creating the application plane of SBT, and passing in an EventManager created using the same EventBus that we used in our control plane. This will ensure that both planes are wired to the same events in Amazon EventBridge. What's missing in this example is the subscription to EventBridge events, and the acting upon those subscriptions. As an application plane developer, a builder could hook up listeners to the various events published by the control plane, and do what's asked in the event. For example, the onboarding event is sent by the control plane with the expectation that the application plane provisions new tenant resources. The event's payload should carry enough information for the application to complete its job. Once done, it's expected that the app plane sends back a status event indicating success or failure. Again, SBT allows builders to publish and subscribe directly to EventBridge, and does not attempt to interfere with that process. However, as part of the SBT library we've published a set of utilities to assist with typical application plane workflows. Let's look one of those utilities now. Once done, we'll come back to this code and fill it in with what we learned.","keywords":"","version":"Next"},{"title":"Install the SaaS Builder Toolkit for AWS","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/install-sbt","content":"Install the SaaS Builder Toolkit for AWS Now that you've initialized a new CDK app, let's install the SBT components. From within the hello-cdk directory, please run the following command: npm install @cdklabs/sbt-aws ","keywords":"","version":"Next"},{"title":"Tutorial Intro","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/intro","content":"","keywords":"","version":"Next"},{"title":"Introduction‚Äã","type":1,"pageTitle":"Tutorial Intro","url":"/sbt-aws/docs/tutorials/tutorial-basics/intro#introduction","content":" ","version":"Next","tagName":"h2"},{"title":"What you'll need‚Äã","type":1,"pageTitle":"Tutorial Intro","url":"/sbt-aws/docs/tutorials/tutorial-basics/intro#what-youll-need","content":" Node.js version 18.0 or above: When installing Node.js, you are recommended to check all checkboxes related to dependencies. AWS Cloud Development Kit version XX or above: Directions for installing are here  ","version":"Next","tagName":"h3"},{"title":"Step 1: CDK getting started‚Äã","type":1,"pageTitle":"Tutorial Intro","url":"/sbt-aws/docs/tutorials/tutorial-basics/intro#step-1-cdk-getting-started","content":" Follow the instructions in CDK's getting started guide. This guide walks you through installing the pre-requisites and ensuring your environment is prepared to build your first CDK app.  ","version":"Next","tagName":"h2"},{"title":"Step 2: Hello SBT!‚Äã","type":1,"pageTitle":"Tutorial Intro","url":"/sbt-aws/docs/tutorials/tutorial-basics/intro#step-2-hello-sbt","content":" Follow the instructions in Step One of CDK's &quot;Hello CDK&quot; project.  You don't have to build or deploy the project, just initialize a new empty project. Once done, come back here, and we'll get started with building your first SBT-enabled multi-tenant app. ","version":"Next","tagName":"h2"},{"title":"Create the control plane","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/create-control-plane","content":"Create the control plane Now that we have SBT installed, let's create a new SBT control plane. Create a new file under /lib/control-plane.ts with the following contents. warning Please be sure to replace the email address with a real email as this is where you'll get the temporary admin password. import * as sbt from '@cdklabs/sbt-aws'; import { Stack } from 'aws-cdk-lib'; import { Construct } from 'constructs'; export class ControlPlaneStack extends Stack { public readonly regApiGatewayUrl: string; public readonly eventManager: sbt.IEventManager; constructor(scope: Construct, id: string, props?: any) { super(scope, id, props); const cognitoAuth = new sbt.CognitoAuth(this, 'CognitoAuth', { // Avoid checking scopes for API endpoints. Done only for testing purposes. setAPIGWScopes: false, }); const controlPlane = new sbt.ControlPlane(this, 'ControlPlane', { auth: cognitoAuth, systemAdminEmail: 'ENTER YOUR EMAIL HERE', }); this.eventManager = controlPlane.eventManager; this.regApiGatewayUrl = controlPlane.controlPlaneAPIGatewayUrl; } } Notice here we're creating a new CDK Stack called &quot;ControlPlaneStack&quot;. In that stack, we're creating a ControlPlane construct which we imported from the @cdklabs/sbt-aws package. Another important concept worth pointing out here is the plugability of this approach. Notice we're creating an &quot;auth&quot; component, called &quot;CognitoAuth&quot;. This component implements the IAuth interface defined in the SBT core package. We currently have a Cognito implementation of IAuth, but we could technically implement that interface with any identity provider.","keywords":"","version":"Next"},{"title":"Provisioning script breakdown","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/provisioning-script-breakdown","content":"","keywords":"","version":"Next"},{"title":"CloudFormation template‚Äã","type":1,"pageTitle":"Provisioning script breakdown","url":"/sbt-aws/docs/tutorials/tutorial-basics/provisioning-script-breakdown#cloudformation-template","content":" Notice the first few lines contains a sample AWS CloudFormation template that contains our S3 Bucket.  # note that this template.json is being created here, but # it could just as easily be pulled in from an S3 bucket. cat &gt; template.json &lt;&lt; EOM { &quot;AWSTemplateFormatVersion&quot;: &quot;2010-09-09&quot;, &quot;Resources&quot;: {&quot;MyBucket&quot;: {&quot;Type&quot;: &quot;AWS::S3::Bucket&quot;}}, &quot;Outputs&quot;: {&quot;S3Bucket&quot;: {&quot;Value&quot;: { &quot;Ref&quot;: &quot;MyBucket&quot; }}} } EOM   In this case we're declaring it inline with the script, but as the comment points out, there's no reason this template couldn't live in an S3 bucket, or any other place supported by the CloudFormation SDK.  Next we're echoing the value of the tenantId and tier environment variables below the CloudFormation template.  ","version":"Next","tagName":"h2"},{"title":"Imported variables('environmentStringVariablesFromIncomingEvent')‚Äã","type":1,"pageTitle":"Provisioning script breakdown","url":"/sbt-aws/docs/tutorials/tutorial-basics/provisioning-script-breakdown#imported-variablesenvironmentstringvariablesfromincomingevent","content":" echo &quot;tenantId: $tenantId&quot; echo &quot;tier: $tier&quot;   Let's examine how exactly those variables get populated. Remember that the ScriptJob (which is used to extend the ProvisioningScriptJob construct) creates an AWS CodeBuild project internally. When the ScriptJob creates the CodeBuild project, it can specify what environment variables to provide. The ScriptJob utility is also triggered by an EventBridge message matching the criteria specified in the incomingEvent parameter of the ScriptJobProps. (You don't need to worry about doing that for ProvisioningScriptJob and DeprovisioningScriptJob because that is already configured.) The message that arrives via EventBridge has a detail JSON Object (see docs here) that carries with it contextual information included by the sender, in our case, the control plane. For each key in the environmentStringVariablesFromIncomingEvent object, the ScriptJob extracts the value of a matching key found in the EventBridge message's detail JSON object, and provides that value to the CodeBuild project as an environment variable.  So, take for example, this sample EventBridge provisioning message sent by a control plane:  { &quot;version&quot;: &quot;0&quot;, &quot;id&quot;: &quot;6a7e8feb-b491-4cf7-a9f1-bf3703467718&quot;, &quot;detail-type&quot;: &quot;onboardingRequest&quot;, &quot;source&quot;: &quot;controlPlaneEventSource&quot;, &quot;account&quot;: &quot;111122223333&quot;, &quot;time&quot;: &quot;2017-12-22T18:43:48Z&quot;, &quot;region&quot;: &quot;us-west-1&quot;, &quot;resources&quot;: [&quot;arn:aws:ec2:us-west-1:123456789012:instance/i-1234567890abcdef0&quot;], &quot;detail&quot;: { &quot;tenantId&quot;: &quot;e6878e03-ae2c-43ed-a863-08314487318b&quot;, &quot;tier&quot;: &quot;standard&quot; } }   When executing, the script cited above would echo both tenantId and tier with the values set according to this message.  ","version":"Next","tagName":"h2"},{"title":"Deploy tenant CloudFormation artifacts‚Äã","type":1,"pageTitle":"Provisioning script breakdown","url":"/sbt-aws/docs/tutorials/tutorial-basics/provisioning-script-breakdown#deploy-tenant-cloudformation-artifacts","content":" Next, we're deploying tenant infrastructure by way of the CloudFormation template we saw above.  aws cloudformation wait stack-create-complete --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot;   ","version":"Next","tagName":"h2"},{"title":"Exported variables ('environmentVariablesToOutgoingEvent')‚Äã","type":1,"pageTitle":"Provisioning script breakdown","url":"/sbt-aws/docs/tutorials/tutorial-basics/provisioning-script-breakdown#exported-variables-environmentvariablestooutgoingevent","content":" The final portion of the script exports environment variables containing information to return to the control plane via the outgoing EventBridge message.  export tenantS3Bucket=$(aws cloudformation describe-stacks --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; | jq -r '.Stacks[0].Outputs[0].OutputValue') export someOtherVariable=&quot;this is a test&quot; echo $tenantS3Bucket export tenantConfig=$(jq --arg SAAS_APP_USERPOOL_ID &quot;MY_SAAS_APP_USERPOOL_ID&quot; \\ --arg SAAS_APP_CLIENT_ID &quot;MY_SAAS_APP_CLIENT_ID&quot; \\ --arg API_GATEWAY_URL &quot;MY_API_GATEWAY_URL&quot; \\ -n '{&quot;userPoolId&quot;:$SAAS_APP_USERPOOL_ID,&quot;appClientId&quot;:$SAAS_APP_CLIENT_ID,&quot;apiGatewayUrl&quot;:$API_GATEWAY_URL}') echo $tenantConfig export tenantStatus=&quot;created&quot;   Similar to how it mapped incoming EventBridge message detail variables to environment variables, the ScriptJob does almost the same thing but in reverse. The variables specified in the environmentVariablesToOutgoingEvent section of ScriptJobProps will be extracted from the environment, and sent back in the EventBridge message's detail section. ","version":"Next","tagName":"h2"},{"title":"Testing the deployment","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/test-the-deployment","content":"Testing the deployment Once deployed, let's run a few tests to see our basic control plane and application plane in action. When you deployed the control plane, you should've received an email with temporary admin credentials. Let's use those credentials now to log in to that account. Please replace the placeholder ('INSERT PASSWORD HERE') with your temporary password in the script below. Once logged in, this script will onboard a new tenant, and retrieve its details. Note this script uses the jq JSON processor. PASSWORD='INSERT PASSWORD HERE' # Change this to a real email if you'd like to log into the tenant TENANT_EMAIL=&quot;tenant@example.com&quot; CONTROL_PLANE_STACK_NAME=&quot;ControlPlaneStack&quot; TENANT_NAME=&quot;tenant$RANDOM&quot; CLIENT_ID=$(aws cloudformation describe-stacks \\ --stack-name &quot;$CONTROL_PLANE_STACK_NAME&quot; \\ --query &quot;Stacks[0].Outputs[?OutputKey=='ControlPlaneIdpClientId'].OutputValue&quot; \\ --output text) USER_POOL_ID=$(aws cloudformation describe-stacks \\ --stack-name &quot;$CONTROL_PLANE_STACK_NAME&quot; \\ --query &quot;Stacks[0].Outputs[?OutputKey=='ControlPlaneIdpUserPoolId'].OutputValue&quot; \\ --output text) USER=&quot;admin&quot; # required in order to initiate-auth aws cognito-idp update-user-pool-client \\ --user-pool-id &quot;$USER_POOL_ID&quot; \\ --client-id &quot;$CLIENT_ID&quot; \\ --explicit-auth-flows USER_PASSWORD_AUTH # remove need for password reset aws cognito-idp admin-set-user-password \\ --user-pool-id &quot;$USER_POOL_ID&quot; \\ --username &quot;$USER&quot; \\ --password &quot;$PASSWORD&quot; \\ --permanent # get credentials for user AUTHENTICATION_RESULT=$(aws cognito-idp initiate-auth \\ --auth-flow USER_PASSWORD_AUTH \\ --client-id &quot;${CLIENT_ID}&quot; \\ --auth-parameters &quot;USERNAME='${USER}',PASSWORD='${PASSWORD}'&quot; \\ --query 'AuthenticationResult') ACCESS_TOKEN=$(echo &quot;$AUTHENTICATION_RESULT&quot; | jq -r '.AccessToken') CONTROL_PLANE_API_ENDPOINT=$(aws cloudformation describe-stacks \\ --stack-name &quot;$CONTROL_PLANE_STACK_NAME&quot; \\ --query &quot;Stacks[0].Outputs[?contains(OutputKey,'controlPlaneAPIEndpoint')].OutputValue&quot; \\ --output text) DATA=$(jq --null-input \\ --arg tenantName &quot;$TENANT_NAME&quot; \\ --arg tenantEmail &quot;$TENANT_EMAIL&quot; \\ '{ &quot;tenantName&quot;: $tenantName, &quot;email&quot;: $tenantEmail, &quot;tier&quot;: &quot;basic&quot;, &quot;tenantStatus&quot;: &quot;In progress&quot; }') echo &quot;creating tenant...&quot; curl --request POST \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}tenants&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --header 'content-type: application/json' \\ --data &quot;$DATA&quot; | jq echo &quot;&quot; # add newline echo &quot;retrieving tenants...&quot; curl --request GET \\ --url &quot;${CONTROL_PLANE_API_ENDPOINT}tenants&quot; \\ --header &quot;Authorization: Bearer ${ACCESS_TOKEN}&quot; \\ --silent | jq Now that we've onboarded a tenant, let's take a look at the console to see what got deployed. First, let's open the DynamoDB console. Once open, click the Explore Items link on the left. On the &quot;Tables&quot; screen, select the table that starts with ControlPlaneStack. Notice there is an entry for the tenant we just onboarded. Also notice it's probably still &quot;in progress&quot; Recall that we deployed a ScriptJob with our application plane, and it's a wrapper around an AWS Step Function that runs our provisioning script via CodeBuild. Let's take a look at that Step Function now by clicking navigating to Step Functions in the console (ensure you're in the same region you deployed to). The Step Function is likely still running, but feel free to examine the execution. Once finished, it'll return the results back to EventBridge, and close the loop with the Control plane.","keywords":"","version":"Next"},{"title":"Putting it all together","type":0,"sectionRef":"#","url":"/sbt-aws/docs/tutorials/tutorial-basics/putting-it-all-together","content":"Putting it all together Now that we've seen the various parts of the application plane in isolation, let's put it all together. Please create the following file in the /lib directory of your CDK app and name it app-plane.ts. Now open that file and paste the following contents into it: import * as sbt from '@cdklabs/sbt-aws'; import * as cdk from 'aws-cdk-lib'; import { EventBus } from 'aws-cdk-lib/aws-events'; import { PolicyDocument, PolicyStatement, Effect } from 'aws-cdk-lib/aws-iam'; export interface AppPlaneProps extends cdk.StackProps { eventManager: sbt.IEventManager; } export class AppPlaneStack extends cdk.Stack { constructor(scope: cdk.App, id: string, props: AppPlaneProps) { super(scope, id, props); const provisioningScriptJobProps: sbt.TenantLifecycleScriptJobProps = { permissions: new PolicyDocument({ statements: [ new PolicyStatement({ actions: [ 'cloudformation:CreateStack', 'cloudformation:DescribeStacks', 's3:CreateBucket', ], resources: ['*'], effect: Effect.ALLOW, }), ], }), script: ` echo &quot;starting...&quot; # note that this template.yaml is being created here, but # it could just as easily be pulled in from an S3 bucket. cat &gt; template.json &lt;&lt; EndOfMessage { &quot;AWSTemplateFormatVersion&quot;: &quot;2010-09-09&quot;, &quot;Resources&quot;: { &quot;MyBucket&quot;:{ &quot;Type&quot;: &quot;AWS::S3::Bucket&quot; }}, &quot;Outputs&quot;: { &quot;S3Bucket&quot;: { &quot;Value&quot;: { &quot;Ref&quot;: &quot;MyBucket&quot; }}} } EndOfMessage echo &quot;tenantId: $tenantId&quot; echo &quot;tier: $tier&quot; aws cloudformation create-stack --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; --template-body &quot;file://template.json&quot; aws cloudformation wait stack-create-complete --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; export tenantS3Bucket=$(aws cloudformation describe-stacks --stack-name &quot;tenantTemplateStack-\\${tenantId}&quot; | jq -r '.Stacks[0].Outputs[0].OutputValue') export someOtherVariable=&quot;this is a test&quot; echo $tenantS3Bucket export tenantConfig=$(jq --arg SAAS_APP_USERPOOL_ID &quot;MY_SAAS_APP_USERPOOL_ID&quot; \\ --arg SAAS_APP_CLIENT_ID &quot;MY_SAAS_APP_CLIENT_ID&quot; \\ --arg API_GATEWAY_URL &quot;MY_API_GATEWAY_URL&quot; \\ -n '{&quot;userPoolId&quot;:$SAAS_APP_USERPOOL_ID,&quot;appClientId&quot;:$SAAS_APP_CLIENT_ID,&quot;apiGatewayUrl&quot;:$API_GATEWAY_URL}') echo $tenantConfig export tenantStatus=&quot;created&quot; echo &quot;done!&quot; `, environmentStringVariablesFromIncomingEvent: ['tenantId', 'tier'], environmentVariablesToOutgoingEvent: [ 'tenantS3Bucket', 'someOtherVariable', 'tenantConfig', 'tenantStatus', ], scriptEnvironmentVariables: { TEST: 'test', }, eventManager: props.eventManager, }; const provisioningJobScript: sbt.ProvisioningScriptJob = new sbt.ProvisioningScriptJob( this, 'provisioningJobScript', provisioningScriptJobProps ); new sbt.CoreApplicationPlane(this, 'CoreApplicationPlane', { eventManager: eventManager, scriptJobs: [provisioningJobScript], }); } } Although this looks like a lot of code, it's still very few constructs. Now that we've defined our app plane, let's again open up the hello-cdk.ts file in the bin directory of your CDK app. Once open, uncomment each commented line. The final file should look like this: #!/usr/bin/env node import 'source-map-support/register'; import * as cdk from 'aws-cdk-lib'; import { ControlPlaneStack } from '../lib/control-plane'; import { AppPlaneStack } from '../lib/app-plane'; const app = new cdk.App(); const controlPlaneStack = new ControlPlaneStack(app, 'ControlPlaneStack'); const appPlaneStack = new AppPlaneStack(app, 'AppPlaneStack', { eventManager: controlPlaneStack.eventManager, }); Once done, ensure all files are saved, and let's deploy the solution again, but this time we'll include the application plane: npm run build cdk deploy ControlPlaneStack AppPlaneStack ","keywords":"","version":"Next"}],"options":{"id":"default"}}